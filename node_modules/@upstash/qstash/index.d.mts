import { R as RateLimit, C as ChatRateLimit, S as Step, F as FailureFunctionPayload, L as LLMOwner, B as BaseProvider, E as EmailOwner, P as ProviderInfo } from './client-DKNfczbM.mjs';
export { A as AddEndpointsRequest, K as BodyInit, X as Chat, Z as ChatCompletion, _ as ChatCompletionChunk, Y as ChatCompletionMessage, a4 as ChatRequest, j as Client, r as CreateScheduleRequest, t as Endpoint, y as Event, D as EventPayload, h as EventsRequest, T as FlowControl, J as GetEventsPayload, i as GetEventsResponse, I as GetLogsPayload, G as GetLogsResponse, H as HTTPMethods, N as HeadersInit, x as Log, z as LogPayload, g as LogsRequest, M as Message, o as MessagePayload, p as Messages, a2 as OpenAIChatModel, a3 as PromptChatRequest, d as PublishBatchRequest, f as PublishJsonRequest, e as PublishRequest, n as PublishResponse, k as PublishToApiResponse, m as PublishToUrlGroupsResponse, l as PublishToUrlResponse, Q as QueueRequest, c as Receiver, a as ReceiverConfig, u as RemoveEndpointsRequest, O as RequestOptions, q as Schedule, s as Schedules, b as SignatureError, w as State, a0 as StreamDisabled, $ as StreamEnabled, a1 as StreamParameter, U as UrlGroup, v as UrlGroups, V as VerifyRequest, W as WithCursor, a7 as anthropic, a8 as custom, a6 as openai, a5 as upstash } from './client-DKNfczbM.mjs';
import 'neverthrow';

/**
 * Result of 500 Internal Server Error
 */
declare class QstashError extends Error {
    readonly status?: number;
    constructor(message: string, status?: number);
}
declare class QstashRatelimitError extends QstashError {
    limit: string | null;
    remaining: string | null;
    reset: string | null;
    constructor(args: RateLimit);
}
declare class QstashChatRatelimitError extends QstashError {
    limitRequests: string | null;
    limitTokens: string | null;
    remainingRequests: string | null;
    remainingTokens: string | null;
    resetRequests: string | null;
    resetTokens: string | null;
    constructor(args: ChatRateLimit);
}
declare class QstashDailyRatelimitError extends QstashError {
    limit: string | null;
    remaining: string | null;
    reset: string | null;
    constructor(args: RateLimit);
}
/**
 * Error raised during Workflow execution
 */
declare class QStashWorkflowError extends QstashError {
    constructor(message: string);
}
/**
 * Raised when the workflow executes a function and aborts
 */
declare class QStashWorkflowAbort extends Error {
    stepInfo?: Step;
    stepName: string;
    constructor(stepName: string, stepInfo?: Step);
}
/**
 * Formats an unknown error to match the FailureFunctionPayload format
 *
 * @param error
 * @returns
 */
declare const formatWorkflowError: (error: unknown) => FailureFunctionPayload;

/**
 * When the base64 string has unicode characters, atob doesn't decode
 * them correctly since it only outputs ASCII characters. Therefore,
 * instead of using atob, we properly decode them.
 *
 * If the decoding into unicode somehow fails, returns the result of atob
 *
 * https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
 *
 * @param base64 encoded string
 */
declare function decodeBase64(base64: string): string;

type AnalyticsConfig = {
    name: "helicone";
    token: string;
};
type AnalyticsSetup = {
    baseURL?: string;
    defaultHeaders?: Record<string, string | undefined>;
};
declare const setupAnalytics: (analytics: AnalyticsConfig | undefined, providerApiKey: string, providerBaseUrl?: string, provider?: LLMOwner) => AnalyticsSetup;

declare class EmailProvider extends BaseProvider<"email", EmailOwner> {
    readonly apiKind = "email";
    readonly batch: boolean;
    readonly method = "POST";
    constructor(baseUrl: string, token: string, owner: EmailOwner, batch: boolean);
    getRoute(): string[];
    getHeaders(_options: unknown): Record<string, string>;
    onFinish(providerInfo: ProviderInfo, _options: unknown): ProviderInfo;
}
declare const resend: ({ token, batch, }: {
    token: string;
    batch?: boolean;
}) => EmailProvider;

export { ChatRateLimit, QStashWorkflowAbort, QStashWorkflowError, QstashChatRatelimitError, QstashDailyRatelimitError, QstashError, QstashRatelimitError, RateLimit, decodeBase64, formatWorkflowError, resend, setupAnalytics };
